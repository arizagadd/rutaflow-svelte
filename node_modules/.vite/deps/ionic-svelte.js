import {
  actionSheetController,
  alertController,
  loadingController,
  menuController,
  modalController,
  pickerController,
  popoverController,
  toastController
} from "./chunk-4NHIYVV4.js";
import "./chunk-7JGIZ2ZG.js";
import "./chunk-HFZPVYTP.js";
import "./chunk-YKLCRUNR.js";
import {
  IonicSlides
} from "./chunk-BNCU6A25.js";
import {
  iosTransitionAnimation
} from "./chunk-IFMDWJTC.js";
import {
  mdTransitionAnimation
} from "./chunk-XI4QCG4H.js";
import "./chunk-WIKEKB2Z.js";
import {
  getTimeGivenProgression
} from "./chunk-KRAWCM2E.js";
import "./chunk-DD5OJKLV.js";
import {
  createAnimation
} from "./chunk-MXGPBZNV.js";
import "./chunk-RL35JESP.js";
import {
  createGesture
} from "./chunk-ANLR7BKM.js";
import {
  initialize
} from "./chunk-GYB7DASA.js";
import "./chunk-Y5XJA2OA.js";
import "./chunk-S3D6T7ZE.js";
import "./chunk-ZG4BI7MI.js";
import {
  readable,
  writable
} from "./chunk-MYYMOB6H.js";
import {
  SvelteComponentDev,
  create_slot,
  dispatch_dev,
  get_all_dirty_from_scope,
  get_slot_changes,
  globals,
  init,
  noop,
  safe_not_equal,
  transition_in,
  transition_out,
  update_slot_base,
  validate_slots
} from "./chunk-UHWICS6C.js";
import "./chunk-JI7YFEPT.js";
import "./chunk-5XOSCENR.js";

// node_modules/ionic-svelte/index.ts
import "/Users/keniasamantha/Documents/GitHub/rutaflow-svelte/node_modules/@ionic/core/css/core.css";
import "/Users/keniasamantha/Documents/GitHub/rutaflow-svelte/node_modules/@ionic/core/css/normalize.css";
import "/Users/keniasamantha/Documents/GitHub/rutaflow-svelte/node_modules/@ionic/core/css/structure.css";
import "/Users/keniasamantha/Documents/GitHub/rutaflow-svelte/node_modules/@ionic/core/css/typography.css";
import "/Users/keniasamantha/Documents/GitHub/rutaflow-svelte/node_modules/@ionic/core/css/padding.css";
import "/Users/keniasamantha/Documents/GitHub/rutaflow-svelte/node_modules/@ionic/core/css/float-elements.css";
import "/Users/keniasamantha/Documents/GitHub/rutaflow-svelte/node_modules/@ionic/core/css/text-alignment.css";
import "/Users/keniasamantha/Documents/GitHub/rutaflow-svelte/node_modules/@ionic/core/css/text-transformation.css";
import "/Users/keniasamantha/Documents/GitHub/rutaflow-svelte/node_modules/@ionic/core/css/flex-utils.css";
import "/Users/keniasamantha/Documents/GitHub/rutaflow-svelte/node_modules/@ionic/core/css/display.css";

// node_modules/ionic-svelte/utils/controllers.ts
var modalController2 = {
  create: (modalOptions) => {
    console.warn("modalController broken - use inline modal - https://github.com/Tommertom/svelte-ionic-app/issues/77");
    console.warn("modalController fails - use inline modal instead - https://github.com/Tommertom/svelte-ionic-app/issues/77");
    return Promise.resolve(
      modalController2.__create(modalOptions.component, modalOptions)
    );
  },
  __create: (component, modalOptions) => {
    const divWrapper = document.createElement("div");
    const contentID = "id" + Date.now();
    divWrapper.id = contentID;
    const modalWrapper = document.createElement(
      "ion-modal"
    );
    if (modalOptions.cssClass) {
      if (Array.isArray(modalOptions.cssClass)) {
        modalOptions.cssClass.forEach((cssClass) => {
          modalWrapper.classList.add(cssClass);
        });
      } else
        modalWrapper.classList.add(modalOptions.cssClass);
    }
    let modalContent = document.createElement("div");
    Object.keys(modalOptions).filter((key) => !["component", "componentProps"].includes(key)).forEach((key) => {
      modalWrapper[key] = modalOptions[key];
    });
    divWrapper.appendChild(modalWrapper);
    modalWrapper.appendChild(modalContent);
    document.body.appendChild(divWrapper);
    const svelteComponent = new component({
      target: modalContent,
      props: modalOptions.componentProps
    });
    modalWrapper.onDidDismiss().then(() => {
      svelteComponent.$destroy();
      divWrapper.remove();
    });
    return modalWrapper;
  },
  dismiss: (data, role, id) => {
    return modalController.dismiss(data, role);
  },
  getTop: () => {
    return modalController.getTop();
  }
};
var popoverController2 = {
  create: (popoverOptions) => {
    return Promise.resolve(
      popoverController2.__create(popoverOptions.component, popoverOptions)
    );
  },
  __create: (component, popoverOptions) => {
    const divWrapper = document.createElement("div");
    const contentID = "id" + Date.now();
    divWrapper.id = contentID;
    const popoverWrapper = document.createElement(
      "ion-popover"
    );
    if (popoverOptions.cssClass) {
      if (Array.isArray(popoverOptions.cssClass)) {
        popoverOptions.cssClass.forEach((cssClass) => {
          popoverWrapper.classList.add(cssClass);
        });
      } else
        popoverWrapper.classList.add(popoverOptions.cssClass);
    }
    let popoverContent = document.createElement("div");
    Object.keys(popoverOptions).filter((key) => !["component", "componentProps"].includes(key)).forEach((key) => {
      popoverWrapper[key] = popoverOptions[key];
    });
    divWrapper.appendChild(popoverWrapper);
    popoverWrapper.appendChild(popoverContent);
    document.body.appendChild(divWrapper);
    const svelteComponent = new component({
      target: popoverContent,
      props: popoverOptions.componentProps
    });
    popoverWrapper.onDidDismiss().then(() => {
      svelteComponent.$destroy();
      divWrapper.remove();
    });
    return popoverWrapper;
  },
  dismiss: (data, role, id) => {
    return popoverController.dismiss(data, role);
  },
  getTop: () => {
    return popoverController.getTop();
  }
};

// node_modules/ionic-svelte/utils/navcontroller.ts
var createHTMLCompFromSvelte = (component, componentProps = {}) => {
  const divWrapper = document.createElement("div");
  const contentID = "id" + Date.now();
  divWrapper.id = contentID;
  const navContent = document.createElement("div");
  divWrapper.appendChild(navContent);
  document.body.appendChild(divWrapper);
  const props = {
    ...componentProps
    // ionNav
  };
  const svelteComponent = new component({
    target: navContent,
    props
  });
  return divWrapper;
};
var navController = {
  canGoBack: function(view) {
    const _nav = document.querySelector("ion-nav");
    return _nav !== void 0 ? _nav.canGoBack(view) : void 0;
  },
  getActive: function() {
    const _nav = document.querySelector("ion-nav");
    return _nav !== void 0 ? _nav.getActive() : void 0;
  },
  getByIndex: function(index) {
    const _nav = document.querySelector("ion-nav");
    return _nav !== void 0 ? _nav.getByIndex(index) : void 0;
  },
  getPrevious: function(view) {
    const _nav = document.querySelector("ion-nav");
    return _nav !== void 0 ? _nav.getPrevious(view) : void 0;
  },
  insert: function(insertIndex, component, componentProps, opts, done) {
    const _nav = document.querySelector("ion-nav");
    const htmlcomponent = createHTMLCompFromSvelte(component, componentProps);
    return _nav !== void 0 ? _nav.insert(insertIndex, htmlcomponent, componentProps, opts, done) : void 0;
  },
  insertPages: function(insertIndex, insertComponents, opts, done) {
    const _nav = document.querySelector("ion-nav");
    const htmlcomponents = insertComponents.map((component) => {
      return typeof component["component"] === "undefined" ? component : {
        //@ts-ignore
        component: createHTMLCompFromSvelte(component["component"], component["componentProps"]),
        //@ts-ignore
        componentProps: component["componentProps"]
      };
    });
    return _nav !== void 0 ? _nav.insertPages(insertIndex, htmlcomponents, opts, done) : void 0;
  },
  pop: function(opts, done) {
    const _nav = document.querySelector("ion-nav");
    return _nav !== void 0 ? _nav.pop(opts, done) : void 0;
  },
  popTo: function(indexOrViewCtrl, opts, done) {
    const _nav = document.querySelector("ion-nav");
    return _nav !== void 0 ? _nav.popTo(indexOrViewCtrl, opts, done) : void 0;
  },
  popToRoot: function(opts, done) {
    const _nav = document.querySelector("ion-nav");
    return _nav !== void 0 ? _nav.popToRoot(opts, done) : void 0;
  },
  push: function(component, componentProps, opts, done) {
    const _nav = document.querySelector("ion-nav");
    const htmlcomponent = createHTMLCompFromSvelte(component, componentProps);
    return _nav !== void 0 ? _nav.push(htmlcomponent, componentProps, opts, done) : void 0;
  },
  removeIndex: function(startIndex, removeCount, opts, done) {
    const _nav = document.querySelector("ion-nav");
    return _nav !== void 0 ? _nav.removeIndex(startIndex, removeCount, opts, done) : void 0;
  },
  setPages: function(views, opts, done) {
    const _nav = document.querySelector("ion-nav");
    const htmlcomponents = views.map((component) => {
      return typeof component["component"] === "undefined" ? component : {
        //@ts-ignore
        component: createHTMLCompFromSvelte(component["component"], component["componentProps"]),
        //@ts-ignore
        componentProps: component["componentProps"]
      };
    });
    return _nav !== void 0 ? _nav.setPages(htmlcomponents, opts, done) : void 0;
  },
  setRoot: function(component, componentProps, opts, done) {
    const _nav = document.querySelector("ion-nav");
    const htmlcomponent = createHTMLCompFromSvelte(component, componentProps);
    return _nav !== void 0 ? _nav.setRoot(htmlcomponent, componentProps, opts, done) : void 0;
  }
};

// node_modules/@ionic/core/dist/collection/global/config.js
var Config = class {
  constructor() {
    this.m = /* @__PURE__ */ new Map();
  }
  reset(configObj) {
    this.m = new Map(Object.entries(configObj));
  }
  get(key, fallback) {
    const value = this.m.get(key);
    return value !== void 0 ? value : fallback;
  }
  getBoolean(key, fallback = false) {
    const val = this.m.get(key);
    if (val === void 0) {
      return fallback;
    }
    if (typeof val === "string") {
      return val === "true";
    }
    return !!val;
  }
  getNumber(key, fallback) {
    const val = parseFloat(this.m.get(key));
    return isNaN(val) ? fallback !== void 0 ? fallback : NaN : val;
  }
  set(key, value) {
    this.m.set(key, value);
  }
};
var config = new Config();

// node_modules/ionic-svelte/utils/platform.ts
var _win;
var _doc;
var getPlatforms = (win) => setupPlatforms(win);
var isPlatform = (winOrPlatform, platform) => {
  if (typeof winOrPlatform === "string") {
    platform = winOrPlatform;
    winOrPlatform = void 0;
  }
  return getPlatforms(winOrPlatform).includes(platform);
};
var setupPlatforms = (win) => {
  if (typeof window !== "undefined") {
    win = window;
    _win = window;
  }
  if (typeof document !== "undefined") {
    _doc = document;
  }
  if (typeof win === "undefined") {
    return [];
  }
  win.Ionic = win.Ionic || {};
  let platforms = win.Ionic.platforms;
  if (platforms == null) {
    platforms = win.Ionic.platforms = detectPlatforms(win);
    platforms.forEach(
      (p) => win.document.documentElement.classList.add(`plt-${p}`)
    );
  }
  return platforms;
};
var detectPlatforms = (win) => {
  const customPlatformMethods = config.get("platform");
  return Object.keys(PLATFORMS_MAP).filter((p) => {
    const customMethod = customPlatformMethods == null ? void 0 : customPlatformMethods[p];
    return typeof customMethod === "function" ? customMethod(win) : PLATFORMS_MAP[p](win);
  });
};
var isMobileWeb = (win) => isMobile(win) && !isHybrid(win);
var isIpad = (win) => {
  if (testUserAgent(win, /iPad/i)) {
    return true;
  }
  if (testUserAgent(win, /Macintosh/i) && isMobile(win)) {
    return true;
  }
  return false;
};
var isIphone = (win) => testUserAgent(win, /iPhone/i);
var isIOS = (win) => testUserAgent(win, /iPhone|iPod/i) || isIpad(win);
var isAndroid = (win) => testUserAgent(win, /android|sink/i);
var isAndroidTablet = (win) => {
  return isAndroid(win) && !testUserAgent(win, /mobile/i);
};
var isPhablet = (win) => {
  const width2 = win.innerWidth;
  const height2 = win.innerHeight;
  const smallest = Math.min(width2, height2);
  const largest = Math.max(width2, height2);
  return smallest > 390 && smallest < 520 && largest > 620 && largest < 800;
};
var isTablet = (win) => {
  const width2 = win.innerWidth;
  const height2 = win.innerHeight;
  const smallest = Math.min(width2, height2);
  const largest = Math.max(width2, height2);
  return isIpad(win) || isAndroidTablet(win) || smallest > 460 && smallest < 820 && largest > 780 && largest < 1400;
};
var isMobile = (win) => matchMedia(win, "(any-pointer:coarse)");
var isDesktop = (win) => !isMobile(win);
var isHybrid = (win) => isCordova(win) || isCapacitorNative(win);
var isCordova = (win) => !!(win["cordova"] || win["phonegap"] || win["PhoneGap"]);
var isCapacitorNative = (win) => {
  const capacitor = win["Capacitor"];
  return !!(capacitor == null ? void 0 : capacitor.isNative);
};
var isElectron = (win) => testUserAgent(win, /electron/i);
var isPWA = (win) => {
  var _a;
  return !!(((_a = win.matchMedia) == null ? void 0 : _a.call(win, "(display-mode: standalone)").matches) || win.navigator.standalone);
};
var testUserAgent = (win, expr) => expr.test(win.navigator.userAgent);
var matchMedia = (win, query) => {
  var _a;
  return (_a = win.matchMedia) == null ? void 0 : _a.call(win, query).matches;
};
var PLATFORMS_MAP = {
  ipad: isIpad,
  iphone: isIphone,
  ios: isIOS,
  android: isAndroid,
  phablet: isPhablet,
  tablet: isTablet,
  cordova: isCordova,
  capacitor: isCapacitorNative,
  electron: isElectron,
  pwa: isPWA,
  mobile: isMobile,
  mobileweb: isMobileWeb,
  desktop: isDesktop,
  hybrid: isHybrid
};
var networkStatus = readable(
  typeof window !== "undefined" ? (window.navigator.onLine ? "on" : "off") + "line" : "",
  (set) => {
    const eventFunction = () => {
      if (typeof window !== "undefined")
        set((window.navigator.onLine ? "on" : "off") + "line");
    };
    if (typeof window !== "undefined") {
      window.addEventListener("offline", eventFunction);
      window.addEventListener("online", eventFunction);
    }
    return () => {
      if (typeof window !== "undefined") {
        window.removeEventListener("offline", eventFunction);
        window.removeEventListener("online", eventFunction);
      }
    };
  }
);
var readableEventFactory = (args) => {
  const { defaultvalue, event, eventAttr, listenerComponent } = args;
  return readable(defaultvalue, (set) => {
    const eventFunction = (event2) => {
      if (eventAttr)
        set(event2[eventAttr]);
      else
        set(event2);
    };
    listenerComponent.addEventListener(event, eventFunction);
    return () => {
      listenerComponent.removeEventListener(event, eventFunction);
    };
  });
};
var resize = readable("", (set) => {
  return () => {
  };
});
var keyboardDidShow = readable("", (set) => {
  return () => {
  };
});
var keyboardDidHide = readable("", (set) => {
  return () => {
  };
});
if (typeof window !== "undefined") {
  resize = readableEventFactory({
    defaultvalue: "",
    event: "resize",
    eventAttr: "timeStamp",
    listenerComponent: window
  });
  keyboardDidShow = readableEventFactory({
    defaultvalue: "",
    event: "ionKeyboardDidShow",
    eventAttr: "",
    listenerComponent: window
  });
  keyboardDidHide = readableEventFactory({
    defaultvalue: "",
    event: "ionKeyboardDidHide",
    eventAttr: "",
    listenerComponent: window
  });
}
var resume = readable("", (set) => {
  return () => {
  };
});
var pause = readable("", (set) => {
  return () => {
  };
});
var backButton = readable("", (set) => {
  return () => {
  };
});
var keydown = readable("", (set) => {
  return () => {
  };
});
if (typeof document !== "undefined") {
  resume = readableEventFactory({
    defaultvalue: "",
    event: "resume",
    eventAttr: "",
    listenerComponent: document
  });
  pause = readableEventFactory({
    defaultvalue: "",
    event: "pause",
    eventAttr: "",
    listenerComponent: document
  });
  backButton = readableEventFactory({
    defaultvalue: "",
    event: "ionBackButton",
    eventAttr: "",
    listenerComponent: document
  });
  keydown = readableEventFactory({
    defaultvalue: "",
    event: "keydown",
    eventAttr: "key",
    listenerComponent: document
  });
}
var backButtonSubscribeWithPriority = (handler, priority = 10) => {
  if (typeof document !== "undefined")
    document.addEventListener("ionBackButton", (ev) => {
      ev.detail.register(priority, () => {
        handler();
        console.log("Handler was called!");
      });
    });
};
var height = () => {
  if (_win)
    return _win.innerHeight;
  return 0;
};
var width = () => {
  if (_win)
    return _win.innerWidth;
  return 0;
};
var url = () => {
  if (_win)
    return _win.location.href;
  return "";
};
var isPortrait = () => {
  var _a;
  if (_win)
    return (_a = _win.matchMedia) == null ? void 0 : _a.call(_win, "(orientation: portrait)").matches;
  return false;
};
var isLandscape = () => {
  return !isPortrait();
};
var getQueryParam = (key) => {
  if (_win)
    return readQueryParam(_win.location.href, key);
  return null;
};
var isRTL = () => {
  if (_doc)
    return _doc.dir === "rtl";
  else
    return false;
};
var is = (platformName) => {
  if (_win)
    return isPlatform(_win, platformName);
  return false;
};
var readQueryParam = (url2, key) => {
  key = key.replace(/[[]/, "\\[").replace(/[\]]/, "\\]");
  const regex = new RegExp("[\\?&]" + key + "=([^&#]*)");
  const results = regex.exec(url2);
  return results ? decodeURIComponent(results[1].replace(/\+/g, " ")) : null;
};
var prefersDark = writable(
  typeof window !== "undefined" ? window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches : ""
);
if (typeof window !== "undefined")
  window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change", (e) => {
    prefersDark.set(e.matches ? true : false);
  });
var toggleDarkTheme = (shouldAdd) => {
  if (_doc)
    document.body.classList.toggle("dark", shouldAdd);
};

// node_modules/ionic-svelte/components/TabsEmpty.svelte
var { console: console_1 } = globals;
function create_fragment(ctx) {
  const block = {
    c: noop,
    l: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TabsEmpty", slots, []);
  console.warn(`Please replace import { IonTabs } from 'ionic-svelte' with import IonTab from 'ionic-svelte/components/IonTabs.svelte'`);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console_1.warn(`<TabsEmpty> was created with unknown prop '${key}'`);
  });
  return [];
}
var TabsEmpty = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TabsEmpty",
      options,
      id: create_fragment.name
    });
  }
};
var TabsEmpty_default = TabsEmpty;

// node_modules/ionic-svelte/components/PageEmpty.svelte
var { console: console_12 } = globals;
function create_fragment2(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[0],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[0],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[0]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[0],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PageEmpty", slots, ["default"]);
  console.warn(`Please replace import { IonPage } from 'ionic-svelte' with import IonPage from 'ionic-svelte/components/IonPage.svelte'`);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console_12.warn(`<PageEmpty> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
var PageEmpty = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PageEmpty",
      options,
      id: create_fragment2.name
    });
  }
};
var PageEmpty_default = PageEmpty;

// node_modules/ionic-svelte/components/NavEmpty.svelte
var { console: console_13 } = globals;
function create_fragment3(ctx) {
  const block = {
    c: noop,
    l: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self, $$props) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("NavEmpty", slots, []);
  console.warn(`Please replace import { IonNav } from 'ionic-svelte' with import IonNav from 'ionic-svelte/components/IonNav.svelte'`);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console_13.warn(`<NavEmpty> was created with unknown prop '${key}'`);
  });
  return [];
}
var NavEmpty = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment3, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "NavEmpty",
      options,
      id: create_fragment3.name
    });
  }
};
var NavEmpty_default = NavEmpty;

// node_modules/ionic-svelte/index.ts
var setupIonicSvelte = async (config2) => {
  console.warn(`setupIonicSvelte will be deprecated - use setupIonicBase and add import 'ionic-svelte/components/all'; - see https://github.com/Tommertom/svelte-ionic-npm/blob/main/CHANGELOG.md#0530 and also for module-shaking options to reduce the size of your bundle. `);
  initialize(config2);
  console.warn("Ionic components not loaded - so your UI will appear broken.");
  if (typeof document !== "undefined") {
    document.documentElement.classList.add("ion-ce");
  }
};
var setupIonicBase = async (config2) => {
  initialize(config2);
  if (typeof document !== "undefined") {
    document.documentElement.classList.add("ion-ce");
  }
};
var registerMenu = (menuId) => {
  const query = "ion-menu[menu-id='" + menuId + "']";
  const menu = document.querySelector(query);
  if (menu) {
    menuController._register(menu);
  }
  return !!menu;
};
export {
  NavEmpty_default as IonNav,
  PageEmpty_default as IonPage,
  TabsEmpty_default as IonTabs,
  IonicSlides,
  actionSheetController,
  alertController,
  backButton,
  backButtonSubscribeWithPriority,
  createAnimation,
  createGesture,
  getPlatforms,
  getQueryParam,
  getTimeGivenProgression,
  height,
  iosTransitionAnimation,
  is,
  isLandscape,
  isPlatform,
  isPortrait,
  isRTL,
  keyboardDidHide,
  keyboardDidShow,
  keydown,
  loadingController,
  mdTransitionAnimation,
  menuController,
  modalController2 as modalController,
  navController,
  networkStatus,
  pause,
  pickerController,
  popoverController2 as popoverController,
  prefersDark,
  registerMenu,
  resize,
  resume,
  setupIonicBase,
  setupIonicSvelte,
  setupPlatforms,
  testUserAgent,
  toastController,
  toggleDarkTheme,
  url,
  width
};
/*! Bundled license information:

@ionic/core/dist/collection/global/config.js:
  (*!
   * (C) Ionic http://ionicframework.com - MIT License
   *)
*/
//# sourceMappingURL=ionic-svelte.js.map
